{"version":3,"sources":["webpack://PointerEvent/webpack/bootstrap","webpack://PointerEvent/./node_modules/anim-event/anim-event.esm.js","webpack://PointerEvent/./src/pointer-event.js"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,MAAM;AACpB,cAAc,SAAS;AACvB;;AAEA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,gBAAgB;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,wEAAS,E;;;;;;;;;;;;ACnHxB;AAAA;AAAA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACnC;AACA;AACA;AACA,oCAAoC;;AAEpC,kBAAkB;AAClB;;AAEA;;AAEA;AACA,gEAAgE;AAChE;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa;AACb;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa,aAAa;AAC1B;;;AAGA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,OAAO;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,qEAAqE;;AAErE,yJAAyJ;;AAEzJ;AACA;AACA;;AAEA;AACA,mCAAmC;;AAEnC;AACA;AACA,SAAS;AACT;AACA;AACA,2EAA2E;;AAE3E,wDAAwD;;AAExD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;;AAEA;AACA;AACA;AACA,2JAA2J;;AAE3J;AACA;AACA,2HAA2H;;AAE3H;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA,MAAM,kDAAS;AACf;AACA,QAAQ;;;AAGR;AACA,oEAAoE;;AAEpE,yJAAyJ;;AAEzJ,0EAA0E;;AAE1E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;;;AAGX;AACA;AACA;AACA,aAAa;AACb;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;;AAEA,gDAAgD,kDAAS;AACzD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA,yHAAyH;AACzH,OAAO;AACP;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA,mEAAmE;;AAEnE,yJAAyJ;;AAEzJ,wEAAwE;;AAExE;AACA;AACA;;AAEA;AACA;AACA,kEAAkE,UAAU;AAC5E;;AAEA;AACA;AACA,WAAW;;;AAGX;AACA;AACA,WAAW;;;AAGX;AACA;AACA;AACA,aAAa;;;AAGb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA,yHAAyH;AACzH,OAAO;AACP;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;;AAEA;AACA,qEAAqE;;AAErE,8BAA8B;AAC9B;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA,sEAAsE;;AAEtE,yJAAyJ;;AAEzJ;AACA;AACA;AACA;;AAEA,wCAAwC;;AAExC;AACA;AACA,kEAAkE,EAAE,OAAO;;AAE3E;AACA;AACA,WAAW;;;AAGX;AACA;AACA,WAAW;;;AAGX;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA,qEAAqE;;AAErE,iCAAiC;AACjC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;;AAEnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;;AAEnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA,CAAC,GAAG;;;AAGJ;AACA,qDAAqD;;AAEtC,2EAAY,E","file":"pointer-event.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/pointer-event.js\");\n","/* ================================================\n        DON'T MANUALLY EDIT THIS FILE\n================================================ */\n\n/*\n * AnimEvent\n * https://github.com/anseki/anim-event\n *\n * Copyright (c) 2021 anseki\n * Licensed under the MIT license.\n */\nvar MSPF = 1000 / 60,\n    // ms/frame (FPS: 60)\nKEEP_LOOP = 500,\n\n/**\n * @typedef {Object} task\n * @property {Event} event\n * @property {function} listener\n */\n\n/** @type {task[]} */\ntasks = [];\n\nvar requestAnim = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n  return setTimeout(callback, MSPF);\n},\n    cancelAnim = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || function (requestID) {\n  return clearTimeout(requestID);\n};\n\nvar lastFrameTime = Date.now(),\n    requestID;\n\nfunction step() {\n  var called, next;\n\n  if (requestID) {\n    cancelAnim.call(window, requestID);\n    requestID = null;\n  }\n\n  tasks.forEach(function (task) {\n    var event;\n\n    if (event = task.event) {\n      task.event = null; // Clear it before `task.listener()` because that might fire another event.\n\n      task.listener(event);\n      called = true;\n    }\n  });\n\n  if (called) {\n    lastFrameTime = Date.now();\n    next = true;\n  } else if (Date.now() - lastFrameTime < KEEP_LOOP) {\n    // Go on for a while\n    next = true;\n  }\n\n  if (next) {\n    requestID = requestAnim.call(window, step);\n  }\n}\n\nfunction indexOfTasks(listener) {\n  var index = -1;\n  tasks.some(function (task, i) {\n    if (task.listener === listener) {\n      index = i;\n      return true;\n    }\n\n    return false;\n  });\n  return index;\n}\n\nvar AnimEvent = {\n  /**\n   * @param {function} listener - An event listener.\n   * @returns {(function|null)} A wrapped event listener.\n   */\n  add: function add(listener) {\n    var task;\n\n    if (indexOfTasks(listener) === -1) {\n      tasks.push(task = {\n        listener: listener\n      });\n      return function (event) {\n        task.event = event;\n\n        if (!requestID) {\n          step();\n        }\n      };\n    }\n\n    return null;\n  },\n  remove: function remove(listener) {\n    var iRemove;\n\n    if ((iRemove = indexOfTasks(listener)) > -1) {\n      tasks.splice(iRemove, 1);\n\n      if (!tasks.length && requestID) {\n        cancelAnim.call(window, requestID);\n        requestID = null;\n      }\n    }\n  }\n};\nexport default AnimEvent;","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * PointerEvent\n * https://github.com/anseki/pointer-event\n *\n * Copyright (c) 2022 anseki\n * Licensed under the MIT license.\n */\nimport AnimEvent from 'anim-event';\nvar MOUSE_EMU_INTERVAL = 400,\n    // Avoid mouse events emulation\nCLICK_EMULATOR_ELEMENTS = [],\n    DBLCLICK_EMULATOR_ELEMENTS = []; // [DEBUG]\n\nvar traceLog = []; // [/DEBUG]\n// Support options for addEventListener\n\nvar passiveSupported = false;\n\ntry {\n  window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n    get: function get() {\n      passiveSupported = true;\n    }\n  }));\n} catch (error) {\n  /* ignore */\n}\n/**\n * addEventListener with specific option.\n * @param {Element} target - An event-target element.\n * @param {string} type - The event type to listen for.\n * @param {function} listener - The EventListener.\n * @param {Object} options - An options object.\n * @returns {void}\n */\n\n\nfunction addEventListenerWithOptions(target, type, listener, options) {\n  // When `passive` is not supported, consider that the `useCapture` is supported instead of\n  // `options` (i.e. options other than the `passive` also are not supported).\n  target.addEventListener(type, listener, passiveSupported ? options : options.capture);\n}\n\nfunction getPointsLength(p0, p1) {\n  var lx = p0.x - p1.x,\n      ly = p0.y - p1.y;\n  return Math.sqrt(lx * lx + ly * ly);\n}\n/**\n * Get Touch instance in list.\n * @param {Touch[]} touches - An Array or TouchList instance.\n * @param {number} id - Touch#identifier\n * @returns {(Touch|null)} - A found Touch instance.\n */\n\n\nfunction getTouchById(touches, id) {\n  if (touches != null && id != null) {\n    for (var i = 0; i < touches.length; i++) {\n      if (touches[i].identifier === id) {\n        return touches[i];\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * @param {Object} xy - Something that might have clientX and clientY.\n * @returns {boolean} - `true` if it has valid clientX and clientY.\n */\n\n\nfunction hasXY(xy) {\n  return xy && typeof xy.clientX === 'number' && typeof xy.clientY === 'number';\n} // Gecko, Trident pick drag-event of some elements such as img, a, etc.\n\n\nfunction dragstart(event) {\n  event.preventDefault();\n}\n\nvar PointerEvent = /*#__PURE__*/function () {\n  /**\n   * Create a `PointerEvent` instance.\n   * @param {Object} [options] - Options\n   */\n  function PointerEvent(options) {\n    var _this = this;\n\n    _classCallCheck(this, PointerEvent);\n\n    this.startHandlers = {};\n    this.lastHandlerId = 0;\n    this.curPointerClass = null;\n    this.curTouchId = null;\n    this.lastPointerXY = {\n      clientX: 0,\n      clientY: 0\n    };\n    this.lastTouchTime = 0; // Options\n\n    this.options = {\n      // Default\n      preventDefault: true,\n      stopPropagation: true\n    };\n\n    if (options) {\n      ['preventDefault', 'stopPropagation'].forEach(function (option) {\n        if (typeof options[option] === 'boolean') {\n          _this.options[option] = options[option];\n        }\n      });\n    }\n  }\n  /**\n   * @param {function} startHandler - This is called with pointerXY when it starts. This returns boolean.\n   * @returns {number} handlerId which is used for adding/removing to element.\n   */\n\n\n  _createClass(PointerEvent, [{\n    key: \"regStartHandler\",\n    value: function regStartHandler(startHandler) {\n      var that = this;\n\n      that.startHandlers[++that.lastHandlerId] = function (event) {\n        traceLog.push('<startListener>', \"type:\".concat(event.type)); // [DEBUG/]\n\n        traceLog.push(\"curPointerClass:\".concat(that.curPointerClass).concat(that.curPointerClass === 'touch' ? \"(#\".concat(that.curTouchId, \")\") : '')); // [DEBUG/]\n\n        var pointerClass = event.type === 'mousedown' ? 'mouse' : 'touch',\n            now = Date.now();\n        var pointerXY, touchId;\n\n        if (pointerClass === 'touch') {\n          that.lastTouchTime = now; // Avoid mouse events emulation\n\n          pointerXY = event.changedTouches[0];\n          touchId = event.changedTouches[0].identifier;\n        } else {\n          // Avoid mouse events emulation\n          if (now - that.lastTouchTime < MOUSE_EMU_INTERVAL) {\n            console.warn(\"Event \\\"\".concat(event.type, \"\\\" was ignored.\")); // [DEBUG/]\n\n            traceLog.push('CANCEL', '</startListener>'); // [DEBUG/]\n\n            return;\n          }\n\n          pointerXY = event;\n        }\n\n        if (!hasXY(pointerXY)) {\n          throw new Error('No clientX/clientY');\n        } // It is new one even if those are 'mouse' or ID is same, then cancel current one.\n\n\n        if (that.curPointerClass) {\n          that.cancel();\n        }\n\n        if (startHandler.call(that, pointerXY)) {\n          that.curPointerClass = pointerClass;\n          that.curTouchId = pointerClass === 'touch' ? touchId : null;\n          traceLog.push(\"curPointerClass:\".concat(that.curPointerClass).concat(that.curPointerClass === 'touch' ? \"(#\".concat(that.curTouchId, \")\") : '')); // [DEBUG/]\n\n          that.lastPointerXY.clientX = pointerXY.clientX;\n          that.lastPointerXY.clientY = pointerXY.clientY;\n          traceLog.push(\"lastPointerXY:(\".concat(that.lastPointerXY.clientX, \",\").concat(that.lastPointerXY.clientY, \")\")); // [DEBUG/]\n\n          if (that.options.preventDefault) {\n            event.preventDefault();\n          }\n\n          if (that.options.stopPropagation) {\n            event.stopPropagation();\n          }\n        }\n\n        traceLog.push('</startListener>'); // [DEBUG/]\n      };\n\n      return that.lastHandlerId;\n    }\n    /**\n     * @param {number} handlerId - An ID which was returned by regStartHandler.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unregStartHandler\",\n    value: function unregStartHandler(handlerId) {\n      delete this.startHandlers[handlerId];\n    }\n    /**\n     * @param {Element} element - A target element.\n     * @param {number} handlerId - An ID which was returned by regStartHandler.\n     * @returns {number} handlerId which was passed.\n     */\n\n  }, {\n    key: \"addStartHandler\",\n    value: function addStartHandler(element, handlerId) {\n      if (!this.startHandlers[handlerId]) {\n        throw new Error(\"Invalid handlerId: \".concat(handlerId));\n      }\n\n      addEventListenerWithOptions(element, 'mousedown', this.startHandlers[handlerId], {\n        capture: false,\n        passive: false\n      });\n      addEventListenerWithOptions(element, 'touchstart', this.startHandlers[handlerId], {\n        capture: false,\n        passive: false\n      });\n      addEventListenerWithOptions(element, 'dragstart', dragstart, {\n        capture: false,\n        passive: false\n      });\n      return handlerId;\n    }\n    /**\n     * @param {Element} element - A target element.\n     * @param {number} handlerId - An ID which was returned by regStartHandler.\n     * @returns {number} handlerId which was passed.\n     */\n\n  }, {\n    key: \"removeStartHandler\",\n    value: function removeStartHandler(element, handlerId) {\n      if (!this.startHandlers[handlerId]) {\n        throw new Error(\"Invalid handlerId: \".concat(handlerId));\n      }\n\n      element.removeEventListener('mousedown', this.startHandlers[handlerId], false);\n      element.removeEventListener('touchstart', this.startHandlers[handlerId], false);\n      element.removeEventListener('dragstart', dragstart, false);\n      return handlerId;\n    }\n    /**\n     * @param {Element} element - A target element.\n     * @param {function} moveHandler - This is called with pointerXY when it moves.\n     * @param {?boolean} rawEvent - Capture events without `requestAnimationFrame`.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addMoveHandler\",\n    value: function addMoveHandler(element, moveHandler, rawEvent) {\n      var that = this;\n\n      AnimEvent.add = function (listener) {\n        return listener;\n      }; // Disable AnimEvent [DEBUG/]\n\n\n      function handler(event) {\n        traceLog.push('<moveListener>', \"type:\".concat(event.type)); // [DEBUG/]\n\n        traceLog.push(\"curPointerClass:\".concat(that.curPointerClass).concat(that.curPointerClass === 'touch' ? \"(#\".concat(that.curTouchId, \")\") : '')); // [DEBUG/]\n\n        var pointerClass = event.type === 'mousemove' ? 'mouse' : 'touch'; // Avoid mouse events emulation\n\n        if (pointerClass === 'touch') {\n          that.lastTouchTime = Date.now();\n        }\n\n        if (pointerClass === that.curPointerClass) {\n          var pointerXY = pointerClass === 'touch' ? getTouchById(event.changedTouches, that.curTouchId) : event;\n\n          if (pointerClass === 'touch' && !pointerXY) {\n            traceLog.push(\"NOT-FOUND-TOUCH(#\".concat(that.curTouchId, \")\"));\n          } // [DEBUG/]\n\n\n          if (hasXY(pointerXY)) {\n            if (pointerXY.clientX !== that.lastPointerXY.clientX || pointerXY.clientY !== that.lastPointerXY.clientY) {\n              that.move(pointerXY);\n            } else {\n              // [DEBUG/]\n              traceLog.push('NOT-CHANGED'); // [DEBUG/]\n            }\n\n            if (that.options.preventDefault) {\n              event.preventDefault();\n            }\n\n            if (that.options.stopPropagation) {\n              event.stopPropagation();\n            }\n          }\n        }\n\n        traceLog.push('</moveListener>'); // [DEBUG/]\n      }\n\n      var wrappedHandler = rawEvent ? handler : AnimEvent.add(handler);\n      addEventListenerWithOptions(element, 'mousemove', wrappedHandler, {\n        capture: false,\n        passive: false\n      });\n      addEventListenerWithOptions(element, 'touchmove', wrappedHandler, {\n        capture: false,\n        passive: false\n      });\n      that.curMoveHandler = moveHandler;\n    }\n    /**\n     * @param {{clientX, clientY}} [pointerXY] - This might be MouseEvent, Touch of TouchEvent or Object.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"move\",\n    value: function move(pointerXY) {\n      traceLog.push('<move>'); // [DEBUG/]\n\n      if (hasXY(pointerXY)) {\n        this.lastPointerXY.clientX = pointerXY.clientX;\n        this.lastPointerXY.clientY = pointerXY.clientY;\n        traceLog.push(\"lastPointerXY:(\".concat(this.lastPointerXY.clientX, \",\").concat(this.lastPointerXY.clientY, \")\")); // [DEBUG/]\n      } else {\n        // [DEBUG/]\n        traceLog.push('NO-pointerXY'); // [DEBUG/]\n      }\n\n      if (this.curMoveHandler) {\n        this.curMoveHandler(this.lastPointerXY);\n      }\n\n      traceLog.push('</move>'); // [DEBUG/]\n    }\n    /**\n     * @param {Element} element - A target element.\n     * @param {function} endHandler - This is called with pointerXY when it ends.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addEndHandler\",\n    value: function addEndHandler(element, endHandler) {\n      var that = this;\n\n      function wrappedHandler(event) {\n        traceLog.push('<endListener>', \"type:\".concat(event.type)); // [DEBUG/]\n\n        traceLog.push(\"curPointerClass:\".concat(that.curPointerClass).concat(that.curPointerClass === 'touch' ? \"(#\".concat(that.curTouchId, \")\") : '')); // [DEBUG/]\n\n        var pointerClass = event.type === 'mouseup' ? 'mouse' : 'touch'; // Avoid mouse events emulation\n\n        if (pointerClass === 'touch') {\n          that.lastTouchTime = Date.now();\n        }\n\n        if (pointerClass === that.curPointerClass) {\n          var pointerXY = pointerClass === 'touch' ? getTouchById(event.changedTouches, that.curTouchId) || ( // It might have been removed from `touches` even if it is not in `changedTouches`.\n          getTouchById(event.touches, that.curTouchId) ? null : {}) : // `{}` means matching\n          event;\n\n          if (pointerClass === 'touch' && (!pointerXY || pointerXY.identifier == null)) {\n            traceLog.push('CHECKED:event.touches');\n          } // [DEBUG/]\n\n\n          if (pointerClass === 'touch' && !pointerXY) {\n            traceLog.push(\"NOT-FOUND-TOUCH(#\".concat(that.curTouchId, \")\"));\n          } // [DEBUG/]\n\n\n          if (pointerXY) {\n            if (!hasXY(pointerXY)) {\n              console.log(\"No pointerXY in event \\\"\".concat(event.type, \"\\\".\"));\n            } // [DEBUG/]\n\n\n            that.end(pointerXY);\n\n            if (that.options.preventDefault) {\n              event.preventDefault();\n            }\n\n            if (that.options.stopPropagation) {\n              event.stopPropagation();\n            }\n          }\n        }\n\n        traceLog.push('</endListener>'); // [DEBUG/]\n      }\n\n      addEventListenerWithOptions(element, 'mouseup', wrappedHandler, {\n        capture: false,\n        passive: false\n      });\n      addEventListenerWithOptions(element, 'touchend', wrappedHandler, {\n        capture: false,\n        passive: false\n      });\n      that.curEndHandler = endHandler;\n    }\n    /**\n     * @param {{clientX, clientY}} [pointerXY] - This might be MouseEvent, Touch of TouchEvent or Object.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"end\",\n    value: function end(pointerXY) {\n      traceLog.push('<end>'); // [DEBUG/]\n\n      if (hasXY(pointerXY)) {\n        this.lastPointerXY.clientX = pointerXY.clientX;\n        this.lastPointerXY.clientY = pointerXY.clientY;\n        traceLog.push(\"lastPointerXY:(\".concat(this.lastPointerXY.clientX, \",\").concat(this.lastPointerXY.clientY, \")\")); // [DEBUG/]\n      } else {\n        // [DEBUG/]\n        traceLog.push('NO-pointerXY'); // [DEBUG/]\n      }\n\n      if (this.curEndHandler) {\n        this.curEndHandler(this.lastPointerXY);\n      }\n\n      this.curPointerClass = this.curTouchId = null;\n      traceLog.push(\"curPointerClass:\".concat(this.curPointerClass)); // [DEBUG/]\n\n      traceLog.push('</end>'); // [DEBUG/]\n    }\n    /**\n     * @param {Element} element - A target element.\n     * @param {function} cancelHandler - This is called when it cancels.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addCancelHandler\",\n    value: function addCancelHandler(element, cancelHandler) {\n      var that = this;\n\n      function wrappedHandler(event) {\n        traceLog.push('<cancelListener>', \"type:\".concat(event.type)); // [DEBUG/]\n\n        traceLog.push(\"curPointerClass:\".concat(that.curPointerClass).concat(that.curPointerClass === 'touch' ? \"(#\".concat(that.curTouchId, \")\") : '')); // [DEBUG/]\n\n        /*\n          Now, this is fired by touchcancel only, but it might be fired even if curPointerClass is mouse.\n        */\n        // const pointerClass = 'touch';\n\n        that.lastTouchTime = Date.now(); // Avoid mouse events emulation\n\n        if (that.curPointerClass != null) {\n          var pointerXY = getTouchById(event.changedTouches, that.curTouchId) || ( // It might have been removed from `touches` even if it is not in `changedTouches`.\n          getTouchById(event.touches, that.curTouchId) ? null : {}); // `{}` means matching\n\n          if (!pointerXY || pointerXY.identifier == null) {\n            traceLog.push('CHECKED:event.touches');\n          } // [DEBUG/]\n\n\n          if (!pointerXY) {\n            traceLog.push(\"NOT-FOUND-TOUCH(#\".concat(that.curTouchId, \")\"));\n          } // [DEBUG/]\n\n\n          if (pointerXY) {\n            that.cancel();\n          }\n        }\n\n        traceLog.push('</cancelListener>'); // [DEBUG/]\n      }\n\n      addEventListenerWithOptions(element, 'touchcancel', wrappedHandler, {\n        capture: false,\n        passive: false\n      });\n      that.curCancelHandler = cancelHandler;\n    }\n    /**\n     * @returns {void}\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      traceLog.push('<cancel>'); // [DEBUG/]\n\n      if (this.curCancelHandler) {\n        this.curCancelHandler();\n      }\n\n      this.curPointerClass = this.curTouchId = null;\n      traceLog.push(\"curPointerClass:\".concat(this.curPointerClass)); // [DEBUG/]\n\n      traceLog.push('</cancel>'); // [DEBUG/]\n    }\n  }], [{\n    key: \"addEventListenerWithOptions\",\n    get: function get() {\n      return addEventListenerWithOptions;\n    }\n    /**\n     * Emulate `click` event via `touchend` event.\n     * @param {Element} element - Target element, listeners that call `event.preventDefault()` are attached later.\n     * @param {?number} moveTolerance - Move tolerance.\n     * @param {?number} timeTolerance - Time tolerance.\n     * @returns {Element} The passed `element`.\n     */\n\n  }, {\n    key: \"initClickEmulator\",\n    value: function initClickEmulator(element, moveTolerance, timeTolerance) {\n      if (CLICK_EMULATOR_ELEMENTS.includes(element)) {\n        return element;\n      }\n\n      CLICK_EMULATOR_ELEMENTS.push(element);\n      var DEFAULT_MOVE_TOLERANCE = 16,\n          // px\n      DEFAULT_TIME_TOLERANCE = 400; // ms\n\n      var startX, startY, touchId, startMs;\n\n      if (moveTolerance == null) {\n        moveTolerance = DEFAULT_MOVE_TOLERANCE;\n      }\n\n      if (timeTolerance == null) {\n        timeTolerance = DEFAULT_TIME_TOLERANCE;\n      }\n\n      addEventListenerWithOptions(element, 'touchstart', function (event) {\n        var touch = event.changedTouches[0];\n        startX = touch.clientX;\n        startY = touch.clientY;\n        touchId = touch.identifier;\n        startMs = performance.now();\n      }, {\n        capture: false,\n        passive: false\n      });\n      addEventListenerWithOptions(element, 'touchend', function (event) {\n        var touch = getTouchById(event.changedTouches, touchId);\n\n        if (typeof startX === 'number' && typeof startY === 'number' && typeof startMs === 'number' && touch && typeof touch.clientX === 'number' && typeof touch.clientY === 'number' && getPointsLength({\n          x: startX,\n          y: startY\n        }, {\n          x: touch.clientX,\n          y: touch.clientY\n        }) <= moveTolerance && performance.now() - startMs <= timeTolerance) {\n          // FIRE\n          setTimeout(function () {\n            var newEvent = new MouseEvent('click', {\n              clientX: touch.clientX,\n              clientY: touch.clientY\n            });\n            newEvent.emulated = true;\n            element.dispatchEvent(newEvent);\n          }, 0);\n        }\n\n        startX = startY = touchId = startMs = null;\n      }, {\n        capture: false,\n        passive: false\n      });\n      addEventListenerWithOptions(element, 'touchcancel', function () {\n        startX = startY = touchId = startMs = null;\n      }, {\n        capture: false,\n        passive: false\n      });\n      return element;\n    }\n    /**\n     * Emulate `dblclick` event via `touchend` event.\n     * @param {Element} element - Target element, listeners that call `event.preventDefault()` are attached later.\n     * @param {?number} moveTolerance - Move tolerance.\n     * @param {?number} timeTolerance - Time tolerance.\n     * @returns {Element} The passed `element`.\n     */\n\n  }, {\n    key: \"initDblClickEmulator\",\n    value: function initDblClickEmulator(element, moveTolerance, timeTolerance) {\n      if (DBLCLICK_EMULATOR_ELEMENTS.includes(element)) {\n        return element;\n      }\n\n      DBLCLICK_EMULATOR_ELEMENTS.push(element);\n      var DEFAULT_MOVE_TOLERANCE = 16,\n          // px\n      DEFAULT_TIME_TOLERANCE = 400; // ms\n\n      var startX, startY, startMs;\n\n      if (moveTolerance == null) {\n        moveTolerance = DEFAULT_MOVE_TOLERANCE;\n      }\n\n      if (timeTolerance == null) {\n        timeTolerance = DEFAULT_TIME_TOLERANCE;\n      }\n\n      PointerEvent.initClickEmulator(element, moveTolerance, timeTolerance);\n      addEventListenerWithOptions(element, 'click', function (event) {\n        if (!event.emulated) {\n          return;\n        } // Ignore events that are not from `touchend`.\n\n\n        if (typeof startX === 'number' && typeof startY === 'number' && typeof startMs === 'number') {\n          // 2nd\n          if (typeof event.clientX === 'number' && typeof event.clientY === 'number' && getPointsLength({\n            x: startX,\n            y: startY\n          }, {\n            x: event.clientX,\n            y: event.clientY\n          }) <= moveTolerance && performance.now() - startMs <= timeTolerance * 2) {\n            // up (tolerance 1) down (tolerance 2) up\n            // FIRE\n            setTimeout(function () {\n              var newEvent = new MouseEvent('dblclick', {\n                clientX: event.clientX,\n                clientY: event.clientY\n              });\n              newEvent.emulated = true;\n              element.dispatchEvent(newEvent);\n            }, 0);\n          }\n\n          startX = startY = startMs = null;\n        } else {\n          // 1st\n          startX = event.clientX;\n          startY = event.clientY;\n          startMs = performance.now();\n        }\n      }, {\n        capture: false,\n        passive: false\n      });\n      return element;\n    }\n  }]);\n\n  return PointerEvent;\n}(); // [DEBUG]\n\n\nPointerEvent.traceLog = traceLog;\nPointerEvent.MOUSE_EMU_INTERVAL = MOUSE_EMU_INTERVAL; // [/DEBUG]\n\nexport default PointerEvent;"],"sourceRoot":""}